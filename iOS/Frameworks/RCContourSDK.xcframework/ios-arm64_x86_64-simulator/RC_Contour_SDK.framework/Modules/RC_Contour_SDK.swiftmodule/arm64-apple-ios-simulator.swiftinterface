// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios15-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name RC_Contour_SDK
import AVFoundation
import ContoursAI_SDK
import CoreLocation
import DeveloperToolsSupport
import Foundation
import Network
@_exported import RC_Contour_SDK
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency open class SkyFloatingLabelTextField : UIKit.UITextField {
  @objc @_Concurrency.MainActor @preconcurrency open var isLTRLanguage: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic open var titleFadeInDuration: Swift.Double
  @objc @_Concurrency.MainActor @preconcurrency dynamic open var titleFadeOutDuration: Swift.Double
  @IBInspectable @_Concurrency.MainActor @preconcurrency @objc override dynamic open var textColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var placeholderColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic open var placeholderFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic open var titleFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var titleColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var lineColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var errorColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var lineErrorColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var textErrorColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var titleErrorColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var disabledColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var selectedTitleColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var selectedLineColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var lineHeight: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic open var selectedLineHeight: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency open var lineView: UIKit.UIView!
  @_Concurrency.MainActor @preconcurrency open var titleLabel: UIKit.UILabel!
  @_Concurrency.MainActor @preconcurrency open var titleFormatter: (_ text: Swift.String) -> Swift.String
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSecureTextEntry: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var errorMessage: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency open var editingOrSelected: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency open var hasErrorMessage: Swift.Bool {
    get
  }
  @IBInspectable @_Concurrency.MainActor @preconcurrency @objc override dynamic open var text: Swift.String? {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor @preconcurrency @objc override dynamic open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var selectedTitle: Swift.String? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var title: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func editingChanged()
  @discardableResult
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @discardableResult
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency open func updateColors()
  @_Concurrency.MainActor @preconcurrency open func setTitleVisible(_ titleVisible: Swift.Bool, animated: Swift.Bool = false, animationCompletion: ((_ completed: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency open func isTitleVisible() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func textRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func editingRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func placeholderRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency open var titleLabelLeftPadding: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open var titleLabelSpacingFromText: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open var titleLabelBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency open var isTitleLabelYPosition: Swift.Bool
  @_Concurrency.MainActor @preconcurrency open func titleLabelRectForBounds(_ bounds: CoreFoundation.CGRect, editing: Swift.Bool) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency open func lineViewRectForBounds(_ bounds: CoreFoundation.CGRect, editing: Swift.Bool) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency open func titleHeight() -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open func textHeight() -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func prepareForInterfaceBuilder()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc deinit
}
public enum IconType : Swift.Int {
  case font
  case image
  case secure
  case none
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol ImageScrollViewDelegate : UIKit.UIScrollViewDelegate {
  @objc func imageScrollViewDidChangeOrientation(imageScrollView: RC_Contour_SDK.ImageScrollView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class ImageScrollView : UIKit.UIScrollView {
  @objc public enum ScaleMode : Swift.Int {
    case aspectFill
    case aspectFit
    case widthFill
    case heightFill
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum Offset : Swift.Int {
    case begining
    case center
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc @_Concurrency.MainActor @preconcurrency open var imageContentMode: RC_Contour_SDK.ImageScrollView.ScaleMode
  @objc @_Concurrency.MainActor @preconcurrency open var initialOffset: RC_Contour_SDK.ImageScrollView.Offset
  @objc @_Concurrency.MainActor @preconcurrency public var zoomView: UIKit.UIImageView? {
    get
  }
  @objc @_Concurrency.MainActor @preconcurrency weak open var imageScrollViewDelegate: (any RC_Contour_SDK.ImageScrollViewDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc @_Concurrency.MainActor @preconcurrency public func adjustFrameToCenter()
  @_Concurrency.MainActor @preconcurrency open func setup()
  @objc @_Concurrency.MainActor @preconcurrency open func display(image: UIKit.UIImage)
  @_Concurrency.MainActor @preconcurrency open func refresh()
}
extension RC_Contour_SDK.ImageScrollView : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewShouldScrollToTop(_ scrollView: UIKit.UIScrollView) -> Swift.Bool
  @available(iOS 11.0, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidChangeAdjustedContentInset(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
}
final public class ActivityData {
  public init(size: CoreFoundation.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, messageSpacing: CoreFoundation.CGFloat? = nil, type: RC_Contour_SDK.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class NVActivityIndicatorPresenter {
  public static let sharedInstance: RC_Contour_SDK.NVActivityIndicatorPresenter
  final public var isAnimating: Swift.Bool {
    get
  }
  final public func startAnimating(_ data: RC_Contour_SDK.ActivityData, _ fadeInAnimation: RC_Contour_SDK.FadeInAnimation? = nil)
  final public func stopAnimating(_ fadeOutAnimation: RC_Contour_SDK.FadeOutAnimation? = nil)
  final public func setMessage(_ message: Swift.String?)
  @objc deinit
}
public protocol NVActivityIndicatorViewable {
}
extension RC_Contour_SDK.NVActivityIndicatorViewable where Self : UIKit.UIViewController {
  public var isAnimating: Swift.Bool {
    get
  }
  public func startAnimating(_ size: CoreFoundation.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, type: RC_Contour_SDK.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, fadeInAnimation: RC_Contour_SDK.FadeInAnimation? = NVActivityIndicatorView.DEFAULT_FADE_IN_ANIMATION)
  public func stopAnimating(_ fadeOutAnimation: RC_Contour_SDK.FadeOutAnimation? = NVActivityIndicatorView.DEFAULT_FADE_OUT_ANIMATION)
}
public enum NVActivityIndicatorType : Swift.CaseIterable {
  case circleStrokeSpin
  public static func == (a: RC_Contour_SDK.NVActivityIndicatorType, b: RC_Contour_SDK.NVActivityIndicatorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [RC_Contour_SDK.NVActivityIndicatorType]
  nonisolated public static var allCases: [RC_Contour_SDK.NVActivityIndicatorType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public typealias FadeInAnimation = (UIKit.UIView) -> Swift.Void
public typealias FadeOutAnimation = (UIKit.UIView, @escaping () -> Swift.Void) -> Swift.Void
@objc @_Concurrency.MainActor @preconcurrency final public class NVActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_TYPE: RC_Contour_SDK.NVActivityIndicatorType
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_TEXT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_PADDING: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_SIZE: CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_DISPLAY_TIME_THRESHOLD: Swift.Int
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_MINIMUM_DISPLAY_TIME: Swift.Int
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_MESSAGE: Swift.String?
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_MESSAGE_SPACING: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_MESSAGE_FONT: UIKit.UIFont
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_BLOCKER_BACKGROUND_COLOR: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_FADE_IN_ANIMATION: (_ view: UIKit.UIView) -> Swift.Void
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_FADE_OUT_ANIMATION: (_ view: UIKit.UIView, _ complete: @escaping () -> Swift.Void) -> Swift.Void
  @_Concurrency.MainActor @preconcurrency final public var type: RC_Contour_SDK.NVActivityIndicatorType
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency final public var color: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency final public var padding: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency final public var animating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency public init(frame: CoreFoundation.CGRect, type: RC_Contour_SDK.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency final public func startAnimating()
  @_Concurrency.MainActor @preconcurrency final public func stopAnimating()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class ProgressView {
  open func showProgressView()
  open func showProgressView(onView: UIKit.UIView, size: CoreFoundation.CGFloat = 80)
  open func showProgressViewOnImage(onView: UIKit.UIImageView, size: CoreFoundation.CGFloat = 80)
  open func hideProgressView()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class IndicatorView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency open func showProgressView(onView: UIKit.UIView, size: CoreFoundation.CGFloat = 20)
  @_Concurrency.MainActor @preconcurrency open func hideProgressView()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Swift.Encodable {
  public var toDictionary: [Swift.String : Any]? {
    get
  }
  public var toData: Foundation.Data? {
    get
  }
}
public struct DispatchHelper {
  public static func delay(bySeconds seconds: Swift.Double = 0.0, dispatchLevel: RC_Contour_SDK.DispatchHelper.DispatchLevel = .main, closure: @escaping () -> Swift.Void)
  public enum DispatchLevel {
    case main, userInteractive, userInitiated, utility, background
    public static func == (a: RC_Contour_SDK.DispatchHelper.DispatchLevel, b: RC_Contour_SDK.DispatchHelper.DispatchLevel) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension UIKit.UILabel {
  @_Concurrency.MainActor @preconcurrency public func setLineSpacing(lineSpacing: CoreFoundation.CGFloat = 0.0, lineHeightMultiple: CoreFoundation.CGFloat = 0.0, minimumLineHeight: CoreFoundation.CGFloat = 0.0)
}
public struct Configuration {
  public var token: Swift.String?
  public var clientId: Swift.String?
  public var termAndCondition: Swift.String?
  public var days: Swift.String?
  public init(token: Swift.String = "", clientID: Swift.String = "")
}
@_hasMissingDesignatedInitializers public class RCContour {
  public static func initialize(configuration: RC_Contour_SDK.Configuration)
  public static func getLaunchScreen() -> UIKit.UIViewController
  public static func getConfiguration() -> RC_Contour_SDK.Configuration
  public func getHistoryScreen(from navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public struct Localizable {
  public init(_ rawValue: Swift.String)
}
public struct UploadCheckRequest {
}
public typealias JSON = [Swift.String : Any]
public typealias CallBackTwoAny = (Any, Any) -> ()
public typealias CallBackAny = (Any) -> ()
public struct NetworkManagerMultipartImage {
  public var requestData: Foundation.Data
  public var imageName: Swift.String
  public var imageFileName: Swift.String
}
extension RC_Contour_SDK.IconType : Swift.Equatable {}
extension RC_Contour_SDK.IconType : Swift.Hashable {}
extension RC_Contour_SDK.IconType : Swift.RawRepresentable {}
extension RC_Contour_SDK.ImageScrollView.ScaleMode : Swift.Equatable {}
extension RC_Contour_SDK.ImageScrollView.ScaleMode : Swift.Hashable {}
extension RC_Contour_SDK.ImageScrollView.ScaleMode : Swift.RawRepresentable {}
extension RC_Contour_SDK.ImageScrollView.Offset : Swift.Equatable {}
extension RC_Contour_SDK.ImageScrollView.Offset : Swift.Hashable {}
extension RC_Contour_SDK.ImageScrollView.Offset : Swift.RawRepresentable {}
extension RC_Contour_SDK.NVActivityIndicatorType : Swift.Equatable {}
extension RC_Contour_SDK.NVActivityIndicatorType : Swift.Hashable {}
extension RC_Contour_SDK.DispatchHelper.DispatchLevel : Swift.Equatable {}
extension RC_Contour_SDK.DispatchHelper.DispatchLevel : Swift.Hashable {}
